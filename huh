class UserListScreen extends StatelessWidget {
  const UserListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final userBox = Hive.box<User>('users');

    return Scaffold(
      appBar: AppBar(title: const Text("Registered Users")),
      // "ValueListenableBuilder" listens for the changes in the Hive box
      // its reactive package of hive
      body: ValueListenableBuilder(
        valueListenable: userBox.listenable(),
        builder: (context, Box<User> box, _) {
          final users = box.values.toList();

          if (users.isEmpty) {
            return const Center(child: Text("No users found."));
          }

          return ListView.builder(
            itemCount: users.length,
            itemBuilder: (context, index) {
              final user = users[index];
              return Dismissible(
                key: Key(user.userId.toString()),
                direction: DismissDirection.endToStart,
                background: Container(
                  color: Colors.red,
                  alignment: Alignment.centerRight,
                  padding: const EdgeInsets.symmetric(horizontal: 20),
                  child: Icon(Icons.delete, color: Colors.white),
                ),
                onDismissed: (direction) {
                  // print("${user.userId} Selected");
                  context.read<UserBloc>().add(DeleteUser(user.userId));
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(
                        '${user.firstName} ${user.lastName} removed',
                      ),
                    ),
                  );
                },
                child: GestureDetector(
                  onTap: () {
                    Navigator.pushNamed(
                      context,
                      '/updateUser',
                      arguments: user.userId,
                    );
                  },
                  child: Card(
                    margin: const EdgeInsets.symmetric(
                      horizontal: 16,
                      vertical: 8,
                    ),
                    child: ListTile(
                      leading: CircleAvatar(child: Text(user.firstName[0])),
                      title: Text("${user.firstName} ${user.lastName}"),
                      subtitle: Text(user.email),
                      trailing: Text("ID: ${user.userId}"),
                    ),
                  ),
                ),
              );
            },
          );
        },
      ),
    );
  }
}




class UserBloc extends Bloc<UserEvent, UserState> {
  final UserRepository userRepository;

  UserBloc({required this.userRepository}) : super(UpdateInitial()) {
    on<UpdateUser>(_onUpdateUser);
    on<DeleteUser>(_onDeleteUser);
  }

  Future<void> _onUpdateUser(UpdateUser event, Emitter<UserState> emit) async {
    emit(UpdateLoading());

    try {
      await userRepository.updateUser(event.updatedUser);
      emit(UpdateSuccess(event.updatedUser));
    } catch (e) {
      emit(UpdateFailure(e.toString()));
    }
  }

  Future<void> _onDeleteUser(DeleteUser event, Emitter<UserState> emit) async {
    emit(UpdateLoading());

    try {
      User? deletedUser = await userRepository.getUserById(event.studentId);
      await userRepository.deleteUser(event.studentId);

      if (deletedUser != null) {
        emit(UpdateSuccess(deletedUser));
      } else {
        emit(UpdateFailure("User not found"));
      }
    } catch (e) {
      emit(UpdateFailure(e.toString()));
    }
  }
}


abstract class UserState extends Equatable {
  @override
  List<Object?> get props => [];
}


class UpdateInitial extends UserState {}

class UpdateLoading extends UserState {}


class UpdateSuccess extends UserState {
  final User user;

  UpdateSuccess(this.user);
  
  // This props list tells Flutter: "If the user changes, then it's a new state"
  // If the user is the same as before, don't update the UI (avoid unnecessary rebuilds)
  @override
  List<Object?> get props => [user];
}


class UpdateFailure extends UserState {
  final String message;

  UpdateFailure(this.message);

  @override
  List<Object?> get props => [message];
}

abstract class UserEvent extends Equatable {
  @override
  List<Object?> get props => [];
}

class UpdateUser extends UserEvent {
  final User updatedUser;

  UpdateUser(this.updatedUser);

  @override
  List<Object?> get props => [updatedUser];
}

class DeleteUser extends UserEvent {
  final int studentId;

  DeleteUser(this.studentId);

  @override
  List<Object?> get props => [studentId];
}






