void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await initDependencies();
  runApp(
    MultiBlocProvider(
      providers: [
        BlocProvider(create: (_) => inj<AuthBloc>()),
        // BlocProvider(create: (_) => inj<UserBloc>()),
        // BlocProvider(create: (_) => ShopBloc()),
        BlocProvider(create: (_) => inj<NavigationBloc>()),
      ],
      child: MaterialApp.router(
        debugShowCheckedModeBanner: false,
        routerConfig: router,
      ),
    ),
  );
}



router
final GoRouter router = GoRouter(
  initialLocation: '/',
  redirect: (context, state) async {
    final sharedPreferences = await SharedPreferences.getInstance();
    final userId = sharedPreferences.getInt('loggedUserId');

    if (userId == null) {
      if (state.matchedLocation == '/login') {
        return null;
      }
      return '/login';
    }

    if (userId != null && state.matchedLocation == '/login') {
      return '/';
    }

    return null;
  },
  routes: [
    GoRoute(
      path: '/login',
      pageBuilder: (context, state) => fadeTransition(const Login(), state),
    ),

    ShellRoute(
      builder: (context, state, child) {
        final authState = context.watch<AuthBloc>().state;
        final userId = authState is AuthSucess ? authState.user.userId : 0;

        return UserMainScreen(child: child, userId: userId);
      },
      routes: [
        GoRoute(
          path: '/',
          pageBuilder:
              (context, state) => fadeTransition(const GameHomePage(), state),
        ),
        GoRoute(
          path: '/user_page/:userId',
          pageBuilder: (context, state) {
            final userId =
                int.tryParse(state.pathParameters['userId'] ?? '') ?? 0;
            return fadeTransition(
              BlocProvider(
                create: (context) => inj<UserBloc>(),
                child: UserPage(userId: userId, transactionType: 1),
              ),
              state,
            );

            // return fadeTransition(UserPage(userId: userId), state);
            // return fadeTransition(ProfileUI(userId: userId), state);
          },
        ),
        GoRoute(
          path: '/profile/:userId',
          pageBuilder: (context, state) {
            final userId =
                int.tryParse(state.pathParameters['userId'] ?? '') ?? 0;
            return fadeTransition(
              BlocProvider(
                create: (context) => inj<UserBloc>(),
                child: UserProfile(userId: userId),
              ),
              state,
            );
          },
        ),
        GoRoute(
          path: '/update_password/:userId',
          pageBuilder: (context, state) {
            final userId =
                int.tryParse(state.pathParameters['userId'] ?? '') ?? 0;
            return fadeTransition(
              BlocProvider(
                create: (context) => inj<UserBloc>(),
                child: UserUpdatePassword(userId: userId),
              ),
              state,
            );
          },
        ),
        GoRoute(
          path: '/game',
          pageBuilder:
              (context, state) => fadeTransition(const GamePage(), state),
        ),
        GoRoute(
          path: '/shop',
          pageBuilder: (context, state) {
            return fadeTransition(
              BlocProvider(
                create: (context) => inj<ShopBloc>(),
                child: ShopPage(),
              ),
              state,
            );
          },
        ),
      ],
    ),
  ],
);

CustomTransitionPage fadeTransition(Widget child, GoRouterState state) {
  return CustomTransitionPage(
    key: state.pageKey,
    child: child,
    transitionsBuilder: (context, animation, secondaryAnimation, child) {
      return FadeTransition(opacity: animation, child: child);
    },
  );
}


injection dependency
final inj = GetIt.instance;

Future<void> initDependencies() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Hive.initFlutter();

  // Hive Model Adapter
  Hive.registerAdapter(UserAdapter());

  final sharedPreferences = await SharedPreferences.getInstance();
  inj.registerLazySingleton<SharedPreferences>(() => sharedPreferences);

  // register box if not existed
  if (!Hive.isBoxOpen('userBox')) {
    await Hive.openBox<User>('userBox');
  }

  if (!Hive.isBoxOpen('counterBox')) {
    await Hive.openBox<int>('counterBox');
  }

  // open box of the transaction database
  if (!Hive.isBoxOpen('transactionBox')) {
    await Hive.openBox<Transaction>('transactionBox');
  }

  if (!Hive.box<int>('counterBox').containsKey('userIdCounter')) {
    Hive.box<int>('counterBox').put('userIdCounter', 0);
  }

  // open box one time
  inj.registerLazySingleton<Box<User>>(() => Hive.box<User>('userBox'));
  inj.registerLazySingleton<Box<int>>(() => Hive.box<int>('counterBox'));
  inj.registerLazySingleton<Box<Transaction>>(
    () => Hive.box<Transaction>('transactionBox'),
  );

  //
  _initSourceRepo();
}

void _initSourceRepo() {
  print("Registering AuthLocalDataSource...");
  inj.registerLazySingleton<AuthLocalDataSource>(
    () => AuthLocalDataSource(
      userBox: inj<Box<User>>(),
      counterBox: inj<Box<int>>(),
      transactionBox: inj<Box<Transaction>>(),
    ),
  );

  print("Registering AuthRepository...");
  inj.registerFactory<AuthRepository>(
    () => AuthRepository(
      authLocalDataSource: inj<AuthLocalDataSource>(),
      sharedPreferences: inj<SharedPreferences>(),
    ),
  );

  print("Registering AuthBloc...");
  inj.registerFactory<AuthBloc>(
    () => AuthBloc(authRepository: inj<AuthRepository>()),
  );

  // Local Data Source
  // inj.registerLazySingleton<AuthLocalDataSource>(
  //   () => AuthLocalDataSource(
  //     userBox: inj<Box<User>>(),
  //     counterBox: inj<Box<int>>(),
  //     transactionBox: inj<Box<Transaction>>(), // added transaction box
  //   ),
  // );

  inj.registerLazySingleton<UserNavLocalDataSource>(
    () => UserNavLocalDataSource(),
  );

  // Auth Repo
  // inj.registerFactory<AuthRepository>(
  //   () => AuthRepository(
  //     authLocalDataSource: inj<AuthLocalDataSource>(),
  //     sharedPreferences: inj<SharedPreferences>(),
  //   ),
  // );

  // pass repo in blocs
  // inj.registerFactory<AuthBloc>(
  //   () => AuthBloc(authRepository: inj<AuthRepository>()),
  // );

  inj.registerFactory<UserBloc>(
    () => UserBloc(authRepository: inj<AuthRepository>()),
  );

  // User Nav
  inj.registerFactory<UserNavigationRepository>(
    () => UserNavigationRepository(
      localDataSource: inj<UserNavLocalDataSource>(),
    ),
  );

  // pass repo in blocs
  inj.registerFactory<NavigationBloc>(
    () => NavigationBloc(
      userNavigationRepository: inj<UserNavigationRepository>(),
    ),
  );
}


error says
E/libEGL  (22038): called unimplemented OpenGL ES API
I/Choreographer(22038): Skipped 5379 frames!  The application may be doing too much work on its main thread.

════════ Exception caught by widgets library ═══════════════════════════════════
The following assertion was thrown building Builder(dependencies: [_InheritedProviderScope<AuthBloc?>]):
_UserMainScreenState.initState() returned a Future.
State.initState() must be a void method without an `async` keyword.
Rather than awaiting on asynchronous work directly inside of initState, call a separate method to do this work without awaiting it.

The relevant error-causing widget was:
...Flutter/tekspog_rush/lib/main.dart:63:26


user main screen
class UserMainScreen extends StatefulWidget {
  final Widget child;
  final int userId;
  const UserMainScreen({super.key, required this.child, required this.userId});

  @override
  State<UserMainScreen> createState() => _UserMainScreenState();
}

class _UserMainScreenState extends State<UserMainScreen> {
  @override
  void initState() {
    // TODO: implement initState
    super.initState();
    _initialize();
  }

  Future<void> _initialize() async {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: []);
    final sharedPreferences = await SharedPreferences.getInstance();
    final userId = sharedPreferences.getInt('loggedUserId');
  }

  @override
  void dispose() {
    // TODO: implement dispose
    super.dispose();
    SystemChrome.setEnabledSystemUIMode(
      SystemUiMode.manual,
      overlays: SystemUiOverlay.values,
    );
  }

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<NavigationBloc, NavigationState>(
      builder: (context, state) {
        return Scaffold(
          appBar: CustomAppBar(userId: widget.userId),
          body: widget.child,
        );
      },
    );
  }
}

