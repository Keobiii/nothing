class UserListScreen extends StatelessWidget {
  const UserListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final userBox = Hive.box<User>('users');

    return Scaffold(
      appBar: AppBar(title: const Text("Registered Users")),
      // "ValueListenableBuilder" listens for the changes in the Hive box
      // its reactive package of hive
      body: ValueListenableBuilder(
        valueListenable: userBox.listenable(),
        builder: (context, Box<User> box, _) {
          final users = box.values.toList();

          if (users.isEmpty) {
            return const Center(child: Text("No users found."));
          }

          return ListView.builder(
            itemCount: users.length,
            itemBuilder: (context, index) {
              final user = users[index];
              return Dismissible(
                key: Key(user.userId.toString()),
                direction: DismissDirection.endToStart,
                background: Container(
                  color: Colors.red,
                  alignment: Alignment.centerRight,
                  padding: const EdgeInsets.symmetric(horizontal: 20),
                  child: Icon(Icons.delete, color: Colors.white),
                ),
                onDismissed: (direction) {
                  // print("${user.userId} Selected");
                  context.read<UserBloc>().add(DeleteUser(user.userId));
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(
                        '${user.firstName} ${user.lastName} removed',
                      ),
                    ),
                  );
                },
                child: GestureDetector(
                  onTap: () {
                    Navigator.pushNamed(
                      context,
                      '/updateUser',
                      arguments: user.userId,
                    );
                  },
                  child: Card(
                    margin: const EdgeInsets.symmetric(
                      horizontal: 16,
                      vertical: 8,
                    ),
                    child: ListTile(
                      leading: CircleAvatar(child: Text(user.firstName[0])),
                      title: Text("${user.firstName} ${user.lastName}"),
                      subtitle: Text(user.email),
                      trailing: Text("ID: ${user.userId}"),
                    ),
                  ),
                ),
              );
            },
          );
        },
      ),
    );
  }
}




class UserBloc extends Bloc<UserEvent, UserState> {
  final UserRepository userRepository;

  UserBloc({required this.userRepository}) : super(UpdateInitial()) {
    on<UpdateUser>(_onUpdateUser);
    on<DeleteUser>(_onDeleteUser);
  }

  Future<void> _onUpdateUser(UpdateUser event, Emitter<UserState> emit) async {
    emit(UpdateLoading());

    try {
      await userRepository.updateUser(event.updatedUser);
      emit(UpdateSuccess(event.updatedUser));
    } catch (e) {
      emit(UpdateFailure(e.toString()));
    }
  }

  Future<void> _onDeleteUser(DeleteUser event, Emitter<UserState> emit) async {
    emit(UpdateLoading());

    try {
      User? deletedUser = await userRepository.getUserById(event.studentId);
      await userRepository.deleteUser(event.studentId);

      if (deletedUser != null) {
        emit(UpdateSuccess(deletedUser));
      } else {
        emit(UpdateFailure("User not found"));
      }
    } catch (e) {
      emit(UpdateFailure(e.toString()));
    }
  }
}


abstract class UserState extends Equatable {
  @override
  List<Object?> get props => [];
}


class UpdateInitial extends UserState {}

class UpdateLoading extends UserState {}


class UpdateSuccess extends UserState {
  final User user;

  UpdateSuccess(this.user);
  
  // This props list tells Flutter: "If the user changes, then it's a new state"
  // If the user is the same as before, don't update the UI (avoid unnecessary rebuilds)
  @override
  List<Object?> get props => [user];
}


class UpdateFailure extends UserState {
  final String message;

  UpdateFailure(this.message);

  @override
  List<Object?> get props => [message];
}

abstract class UserEvent extends Equatable {
  @override
  List<Object?> get props => [];
}

class UpdateUser extends UserEvent {
  final User updatedUser;

  UpdateUser(this.updatedUser);

  @override
  List<Object?> get props => [updatedUser];
}

class DeleteUser extends UserEvent {
  final int studentId;

  DeleteUser(this.studentId);

  @override
  List<Object?> get props => [studentId];
}




class AuthBloc extends Bloc<AuthEvent, AuthState> {
  final UserRepository userRepository;

  AuthBloc({required this.userRepository}) : super(AuthInitial()) {
    on<RegisterUser>(_onRegisterUser);
    on<LoginUser>(_onLoginUser);
  }

  // Future - represents a value that will be available later, like a promise.
  // In this case, "_onRegisterUser" is an async function that promises to complete later.
  // It doesn't return any data (void), but it performs an action: registering a user.

  // void - means this function doesn't return any value.
  // If we changed "void" to String, int, or User, that would mean it returns that data type.

  // async - makes this function asynchronous.
  // It allows us to use "await", which pauses the function until the awaited operation finishes.

  // Emitter - comes from BLoC. It's used to emit new states (like loading, success, failure).
  // When we emit a state, the UI listens and updates based on that state.

  Future<void> _onRegisterUser(
    RegisterUser event,
    Emitter<AuthState> emit,
  ) async {
    // Tell the UI we're doing something (like showing a loading spinner)
    emit(AuthLoading());

    try {
      // Try to add the user (like saving to Hive or a database)
      await userRepository.addUser(event.user);

      // If it's successful, emit AuthSuccess and pass the registered user
      emit(AuthSuccess(event.user));
    } catch (e) {
      // If there's an error (like saving failed), emit an error state
      emit(AuthFailure("Failed to register user."));
    }
  }

  Future<void> _onLoginUser(LoginUser event, Emitter<AuthState> emit) async {
    emit(AuthLoading());

    final user = await userRepository.getUserByNameAndPassword(
      event.email,
      event.password,
    );

    if (user != null) {
      // Save to SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.setInt('userId', user.userId);
      await prefs.setInt('userRole', user.userRole);

      emit(AuthSuccess(user));
      print('User Role: ${user.userRole}');
    } else {
      emit(AuthFailure("Invalid credentials."));

      print('Failed: ');
    }
  }
}




abstract class AuthEvent extends Equatable {
  @override
  List<Object?> get props => [];
}

class RegisterUser extends AuthEvent {
  final User user;

  RegisterUser(this.user);

  @override
  List<Object?> get props => [user];
}

class LoginUser extends AuthEvent {
  final String email;
  final String password;

  LoginUser({required this.email, required this.password});

  @override
  List<Object?> get props => [email, password];
}


abstract class AuthState extends Equatable {
  @override
  List<Object?> get props => [];
}

class AuthInitial extends AuthState {}

class AuthLoading extends AuthState {}



class AuthSuccess extends AuthState {
  final User user;

  AuthSuccess(this.user);
  
  // This props list tells Flutter: "If the user changes, then it's a new state"
  // If the user is the same as before, don't update the UI (avoid unnecessary rebuilds)
  @override
  List<Object?> get props => [user];
}


class AuthFailure extends AuthState {
  final String message;

  AuthFailure(this.message);

  @override
  List<Object?> get props => [message];
}








void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Hive
  await Hive.initFlutter();

  // Register Adapter
  Hive.registerAdapter(UserAdapter());
  Hive.registerAdapter(ProductAdapter());
  Hive.registerAdapter(OrderAdapter());

  // Open the box
  await Hive.openBox<User>('users');
  await Hive.openBox<Product>('products');
  await Hive.openBox<Order>('orders');

  // runApp(const MyApp());

  runApp(
    MultiBlocProvider(
      providers: [
        RepositoryProvider(create: (_) => UserRepository()),
        RepositoryProvider(create: (_) => ProductRepository()),
        RepositoryProvider(create: (_) => OrderRepository()),
        BlocProvider(
          create:
              (context) =>
                  AuthBloc(userRepository: context.read<UserRepository>()),
        ),
        BlocProvider(
          create:
              (context) =>
                  UserBloc(userRepository: context.read<UserRepository>()),
        ),
        BlocProvider(
          create:
              (context) => ProductBloc(
                productRepository: context.read<ProductRepository>(),
              ),
        ),
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Hive + BLoc',
      theme: ThemeData.dark().copyWith(
        scaffoldBackgroundColor: Pallete.backgroundColor,
      ),
      initialRoute: '/',
      onGenerateRoute: RouteGenerator.generateRoute,
    );
  }
}




class RouteGenerator {
  static Route<dynamic> generateRoute(RouteSettings settings) {
    switch (settings.name) {
      case '/':
        return MaterialPageRoute(
          builder:
              (_) => BlocProvider(
                create:
                    (context) => AuthBloc(
                      userRepository: context.read<UserRepository>(),
                    ),
                child: const LoginScreen(),
              ),
        );
      case '/signup':
        return MaterialPageRoute(
          builder:
              (_) => BlocProvider(
                create:
                    (context) => AuthBloc(
                      userRepository: context.read<UserRepository>(),
                    ),
                child: const SignUpScreen(),
              ),
        );
      case '/list':
        return MaterialPageRoute(
          builder:
              (_) => BlocProvider(
                create:
                    (context) => UserBloc(
                      userRepository: context.read<UserRepository>(),
                    ),
                child: const UserListScreen(),
              ),
        );
      case '/updateUser':
        // Expecting the Page that passing userId
        final userId = settings.arguments as int;
        return MaterialPageRoute(
          builder:
              (_) => BlocProvider(
                create:
                    (context) => UserBloc(
                      userRepository: context.read<UserRepository>(),
                    ),
                child: UpdateUserData(userId: userId),
              ),
        );
      case '/userPage':
        return MaterialPageRoute(
          builder:
              (_) => MultiBlocProvider(
                providers: [
                  BlocProvider(
                    create:
                        (context) => OrderBloc(
                          orderRepository: context.read<OrderRepository>(),
                        ),
                  ),
                  BlocProvider(
                    create:
                        (context) => ProductBloc(
                          productRepository: context.read<ProductRepository>(),
                        ),
                  ),
                ],
                child: const UserScreen(),
              ),
        );
      case '/orderPage':
        return MaterialPageRoute(
          builder:
              (_) => MultiBlocProvider(
                providers: [
                  BlocProvider(
                    create:
                        (context) => UserBloc(
                          userRepository: context.read<UserRepository>(),
                        ),
                  ),
                  BlocProvider(
                    create:
                        (context) => AuthBloc(
                          userRepository: context.read<UserRepository>(),
                        ),
                  ),
                  BlocProvider(
                    create:
                        (context) => OrderBloc(
                          orderRepository: context.read<OrderRepository>(),
                        ),
                  ),
                ],
                child: const OrderPage(),
              ),
        );
      case '/userOrderList':
        return MaterialPageRoute(
          builder:
              (_) => BlocProvider(
                create:
                    (context) => OrderBloc(
                      orderRepository: context.read<OrderRepository>(),
                    ),
                child: const OrderListPage(),
              ),
        );
      case '/sellerPage':
        return MaterialPageRoute(
          builder:
              (_) => MultiBlocProvider(
                providers: [
                  BlocProvider(
                    create:
                        (context) => ProductBloc(
                          productRepository: context.read<ProductRepository>(),
                        ),
                  ),
                ],
                child: const SellerScreen(),
              ),
        );
      case '/addProduct':
        return MaterialPageRoute(
          builder:
              (_) => MultiBlocProvider(
                providers: [
                  BlocProvider(
                    create:
                        (context) => ProductBloc(
                          productRepository: context.read<ProductRepository>(),
                        ),
                  ),
                ],
                child: const ProductForm(),
              ),
        );
      case '/listProduct':
        return MaterialPageRoute(
          builder:
              (_) => MultiBlocProvider(
                providers: [
                  BlocProvider(
                    create:
                        (context) => ProductBloc(
                          productRepository: context.read<ProductRepository>(),
                        ),
                  ),
                ],
                child: const ListProduct(),
              ),
        );
      case '/updateProduct':
        // Expecting the Page that passing userId
        final productId = settings.arguments as int;
        return MaterialPageRoute(
          builder:
              (_) => BlocProvider(
                create:
                    (context) => ProductBloc(
                      productRepository: context.read<ProductRepository>(),
                    ),
                child: UpdateProductData(productId: productId),
              ),
        );
      case '/listOrder':
        return MaterialPageRoute(
          builder:
              (_) => BlocProvider(
                create:
                    (context) => OrderBloc(
                      orderRepository: context.read<OrderRepository>(),
                    ),
                child: const ListOrders(),
              ),
        );
      case '/updateOrder':
        final orderId = settings.arguments as int;
        return MaterialPageRoute(
          builder:
              (_) => BlocProvider(
                create:
                    (context) => OrderBloc(
                      orderRepository: context.read<OrderRepository>(),
                    ),
                child: UpdateOrder(orderId: orderId),
              ),
        );
      default:
        return _errorRoute();
    }
  }

  static Route<dynamic> _errorRoute() {
    return MaterialPageRoute(
      builder: (_) {
        return Scaffold(
          appBar: AppBar(title: const Text('No Route'), centerTitle: true),
          body: const Center(
            child: Text(
              'Sorry route not found',
              style: TextStyle(color: Colors.red, fontSize: 18.0),
            ),
          ),
        );
      },
    );
  }
}








