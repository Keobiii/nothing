package com.example.myapplication

import android.view.MotionEvent
import androidx.annotation.OptIn
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.runtime.snapshots.SnapshotStateList
import androidx.compose.ui.ExperimentalComposeUiApi
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.clipToBounds
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Rect
import androidx.compose.ui.graphics.ClipOp
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.ImageBitmap
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.drawscope.clipPath
import androidx.compose.ui.input.pointer.pointerInteropFilter
import androidx.compose.ui.res.imageResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import androidx.media3.common.util.Log
import androidx.media3.common.util.UnstableApi
import com.example.myapplication.Dialog.CustomCardDialog
import kotlin.random.Random


@Composable
@OptIn(UnstableApi::class)
fun ScratchWin() {
    var showDialog by remember { mutableStateOf(false) }
    var resetTrigger by remember { mutableStateOf(0) }

    val imageResList = remember {
        getRandomBombDiamondImages(R.drawable.diamond, R.drawable.bomb)
    }

    val revealedList = remember { mutableStateListOf<Boolean>().apply {
        addAll(List(imageResList.size) { false })
    } }

    val scratchPoints = remember { List(imageResList.size) { mutableStateListOf<Offset>() } }


    var diamondCount by remember { mutableStateOf(0) }
    var bombCount by remember { mutableStateOf(0) }


    fun resetGame() {
        resetTrigger++
    }

    // function to update the counts
    fun onDiamondBombCount(imageRes: Int) {
        when (imageRes) {
            R.drawable.diamond -> diamondCount++
            R.drawable.bomb -> bombCount++
        }

        // Log the updated count

    }

    Log.i("Diamond Count: ", diamondCount.toString())
    Log.i("Bomb Count: ", bombCount.toString())

    if (showDialog) {
        CustomCardDialog(
            onDismiss = { showDialog = false },
            fontFamily = FontFamily.SansSerif,
            title = if (diamondCount == 3 && bombCount <= 6) "Panalo" else "Talo",
            description = "Bomb: $bombCount : Diamond: $diamondCount"
        )
    }
    


    LazyVerticalGrid(
        columns = GridCells.Fixed(3),
        modifier = Modifier
            .fillMaxHeight()
            .border(1.dp, Color.Red),
        horizontalArrangement = Arrangement.Center,
        verticalArrangement = Arrangement.Center,
        userScrollEnabled = false,
        content = {
            items(9) { index ->
                ScracthCardScreen(
                    baseImage = imageResList[index],
                    overlayImage = R.drawable.coin,
                    index = index,
                    revealedList = revealedList,
                    onDiamondBombCount = { imageRes ->
                        if (!revealedList[index]) {
                            revealedList[index] = true
                            onDiamondBombCount(imageRes)
                        }
                    },
                    onRevealChanged = { id, revealed ->
                        if (revealed && revealedList.all { it }) {
                            Log.i("Scratch", "All items revealed!")
//                            showDialog = true
                            Log.i("ID Value", id.toString())
                        }
                    },
                    scratchPoints = scratchPoints[index]
                )
            }
        }
    )
}


@OptIn(UnstableApi::class)
@kotlin.OptIn(ExperimentalComposeUiApi::class)
@Composable
fun ScracthCardScreen(
    baseImage: Int,
    overlayImage: Int,
    index: Int,
    onDiamondBombCount: (Int) -> Unit,
    revealedList: MutableList<Boolean>,
    onRevealChanged: (Int, Boolean) -> Unit,
    scratchPoints: SnapshotStateList<Offset>
) {
    val basedImage = ImageBitmap.imageResource(id = baseImage)
    val overlayImage = ImageBitmap.imageResource(id = overlayImage)

    val currentPathState = remember { mutableStateOf(DraggedPath(path = Path())) }
    val movedOffsetState = remember { mutableStateOf<Offset?>(null) }

    val currentPath = currentPathState.value.path
    val currentPathThickness = currentPathState.value.width

//    Log.i("Diamond Bomb: ", onDiamondBombCount(baseImage).toString())
    onDiamondBombCount(baseImage)
    Canvas(
        modifier = Modifier
            .fillMaxWidth()
            .height(100.dp)
            .clipToBounds()
            .padding(5.dp)
            .clip(RoundedCornerShape(16.dp))
            .border(1.dp, Color.LightGray, RoundedCornerShape(16.dp))
            .pointerInteropFilter {
                when (it.action) {
                    MotionEvent.ACTION_DOWN -> {
                        currentPath.moveTo(it.x, it.y)
                        scratchPoints.clear()
                        scratchPoints.add(Offset(it.x, it.y))
                    }
                    MotionEvent.ACTION_MOVE -> {
                        movedOffsetState.value = Offset(it.x, it.y)
                        scratchPoints.add(Offset(it.x, it.y))
                    }
                }
                true
            },
    ) {

        val canvasWidth = size.width.toInt()
        val canvasHeight = size.height.toInt()
        val imageSize = IntSize(canvasWidth, canvasHeight)

        drawImage(
            image = overlayImage,
            dstSize = imageSize
        )

        movedOffsetState.value?.let {
            currentPath.addOval(oval = Rect(it, currentPathThickness))
        }

        clipPath(
            path = currentPath,
            clipOp = ClipOp.Intersect
        ) {
            drawImage(
                image = basedImage,
                dstSize = imageSize
            )
        }

        // Check if the card is revealed, and update counts
        if (isCardRevealed(scratchPoints)) {
            if (!revealedList[index]) {
                revealedList[index] = true
                onRevealChanged(index, true)
            }
        }
    }
}


fun isCardRevealed(scratchPoints: MutableList<Offset>): Boolean {
    val threshold = 10

    return scratchPoints.size >= threshold
}

fun getRandomBombDiamondImages(diamond: Int, bomb: Int): List<Int> {
    val imageList = mutableListOf<Int>()

    val diamondCount = Random.nextInt(1, 4)
    val bombCount = 9 - diamondCount

    repeat(diamondCount) { imageList.add(diamond) }
    repeat(bombCount) { imageList.add(bomb) }


    return imageList.shuffled()
}
